# X) Summary of references.  
Could not read Applied Cryptography: Protocols, Algorithms and Source Code in C, 20th Anniversary Edition  
## Karvinen 2024: [Python Basics for Hackers](https://terokarvinen.com/python-for-hackers/)  
- Using a interactive code manipulator/interpreter is useful for faster feedback.
- Great ways to write code and get fast feedback are iPython and micro.

# Crypto Challenge Set 1
## Convert hex to base64
In this challenge I had to convert a single hex string in to base 64.  
I have done a little coding in my younger days, so I was a bit rusty. I knew from our lessons that using the `base64.b64encode` function is propably the right call here, so I tried to use it.  
I unfortunately did not remeber any of the python syntax, so I had to ask Microsoft CoPilot for some help how to do this.  
But after a bit of trial and error, I managed to get the the string converted to base64  
<img width="608" height="185" alt="image" src="https://github.com/user-attachments/assets/529af128-c74f-4019-b298-de938cdac6ca" />  
## Fixed XOR
In thois challenge i had to do a bitwise XOR to two strings.  
At first I converted the two string in to binaries and saved them as variables a and b.  
Then tried doing the xorring, but ran in to a plethora of syntax errors so i once again asked Microsoft CoPilot to help me with syntax and to explain to me what each part of the code did.  
Here is the answer  
```
import binascii
a = binascii.a2b_hex("1c0111001f010100061a024b53535009181c")
b = binascii.a2b_hex("686974207468652062756c6c277320657965")
    xor = bytes(x ^ y for x, y in zip(a, b))
    print(xor.decode())
```

The codebit that does the xor, pairs the two string with the `zip (a,b)` so that each bit from a corresponds to the same bit in b.  
Then the for loop goes over each bit and xors it with the corresponding bit.  
Then the `bytes` returns a new byte-string.  
Then lastly. `xor.decode()` converts the string into ASCII.  
And the answer i got was "the kid don't play"  
After doing this I re-read the assignement and figured that the assignement asked for a hex result, not ascii. So i added this piece of code so that i got it.  

`xxor = binascii.b2a_hex(xor).decode()/n print(xxor)`  

## Single-byte XOR cipher
Okay, I had no ******* clue how to even start this one. So Microsoft CoPilot once again saved my ass.  
I asked Microsoft CoPilot on how to do this and tried my best to understand how the code does this, but the code syntax is still a bit fuzzy.  
Here is the code that I got working.  
```import binascii

freq_chars = b'ETAOIN SHRDLUetaoinshrdlu '

def score_text(text):
    return sum(text.count(c) for c in freq_chars)

def single_byte_xor_brute_force(hex_str):
    data = binascii.a2b_hex(hex_str)
    candidates = []
    for key in range(256):
        xored = bytes([b ^ key for b in data])
        try:
            decoded = xored.decode('utf-8')
            score = score_text(xored)
            candidates.append((score, key, decoded))
        except:
            continue
    candidates.sort(reverse=True)
    return candidates

cipher_hex = "1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736"
results = single_byte_xor_brute_force(cipher_hex)

for score, key, text in results[:5]:
    print(f"Key: {key:02x} | Score: {score} | Text: {text}")
````

And the most propable answer I got was "Cooking MC's like a pound of bacon"  
I still have a lot of learning to do with python and coding in general to make sense of what the code does.  
## Detect single-character XOR  
Once again, Microsoft Copilot comes to my rescue.  
I did spend some time pondering on how i would modify my previous code so that it would go over the wordlist and pick the best candidate, but my coding abilities are so lacking that the task seemed impossible.  
So i asked CoPilot to modify the code so it could do the task at hand.  
Here is the code that was produced.  

````
import sys
import binascii
from collections import Counter

# Frequency table for scoring (approximate English letter frequencies)
english_freq = {
    'a': 0.08167, 'b': 0.01492, 'c': 0.02782, 'd': 0.04253, 'e': 0.12702,
    'f': 0.02228, 'g': 0.02015, 'h': 0.06094, 'i': 0.06966, 'j': 0.00153,
    'k': 0.00772, 'l': 0.04025, 'm': 0.02406, 'n': 0.06749, 'o': 0.07507,
    'p': 0.01929, 'q': 0.00095, 'r': 0.05987, 's': 0.06327, 't': 0.09056,
    'u': 0.02758, 'v': 0.00978, 'w': 0.02360, 'x': 0.00150, 'y': 0.01974,
    'z': 0.00074, ' ': 0.13000
}

def score_text(text_bytes):
    """Score bytes using english_freq. Non-ascii bytes score 0."""
    s = 0.0
    for b in text_bytes:
        c = chr(b).lower()
        s += english_freq.get(c, 0)
    return s

def single_byte_xor_brute_force_bytes(data_bytes):
    """Return list of (score, key, decrypted_bytes) for all 256 keys (sorted desc)."""
    candidates = []
    for key in range(256):
        xored = bytes([b ^ key for b in data_bytes])
        # Try to ensure it is likely a textual candidate: allow decode if possible
        # We'll still score binary-like results but prefer decodable text.
        try:
            xored.decode('utf-8')  # valid UTF-8 check
        except UnicodeDecodeError:
            # still compute score (non-decodable -> likely poor score), but mark low priority
            score = score_text(xored)
            candidates.append((score, key, xored))
            continue
        score = score_text(xored)
        candidates.append((score, key, xored))
    candidates.sort(reverse=True, key=lambda t: t[0])
    return candidates

def analyze_file(filename, top_n_per_line=3):
    best_overall = None  # tuple (score, key, bytes, line_no, raw_hex)
    with open(filename, 'r') as f:
        for line_no, raw in enumerate(f, start=1):
            hex_str = raw.strip()
            if not hex_str:
                continue
            # clean possible spaces in hex string
            hex_str_clean = ''.join(hex_str.split())
            # skip lines that aren't valid hex or not length 60 (optional)
            try:
                data = binascii.unhexlify(hex_str_clean)
            except (binascii.Error, ValueError):
                print(f"Line {line_no}: skipping invalid hex -> {hex_str!r}")
                continue

            candidates = single_byte_xor_brute_force_bytes(data)
            # report top N candidates for this line
            print(f"\nLine {line_no} (hex len={len(hex_str_clean)}): top {top_n_per_line} candidates:")
            for i, (score, key, dec_bytes) in enumerate(candidates[:top_n_per_line], start=1):
                # decode for printing safely; replace undecodable bytes
                dec_text = dec_bytes.decode('utf-8', errors='replace')
                print(f"  {i}. Score: {score:.5f} | Key: {key} (0x{key:02x}) | Text: {dec_text}")

            # update overall best
            top_score, top_key, top_dec = candidates[0]
            if (best_overall is None) or (top_score > best_overall[0]):
                best_overall = (top_score, top_key, top_dec, line_no, hex_str_clean)

    # final summary
    if best_overall:
        bscore, bkey, bdec, blineno, bhex = best_overall
        print("\n" + "="*60)
        print("Best overall candidate:")
        print(f" Line: {blineno}")
        print(f" Hex (line): {bhex}")
        print(f" Key: {bkey} (0x{bkey:02x})")
        print(f" Score: {bscore:.5f}")
        print(" Decrypted text:")
        print(bdec.decode('utf-8', errors='replace'))
        print("="*60)
    else:
        print("No valid candidates found.")

if __name__ == "__main__":
    if len(sys.argv) >= 2:
        filename = sys.argv[1]
    else:
        # default filename; change if you like
        filename = "hex_strings.txt"

    analyze_file(filename, top_n_per_line=3)

````
And the answer was...  
<img width="335" height="88" alt="image" src="https://github.com/user-attachments/assets/87015ce9-79c0-4561-aad3-133226f7ec68" />  

# Sources  
Karvinen 2024: [Get Started Micro Editor](https://terokarvinen.com/get-started-micro-editor/)  
Karvinen 2024: [Getting Started with Cryptopals using Python](https://terokarvinen.com/getting-started-python-cryptopals/)  
Karvinen 2024: [Sovellusten hakkerointi](https://terokarvinen.com/sovellusten-hakkerointi/)  
A special thanks to generative AI for carrying my ass :)








